#!/bin/bash
#=================================================================================
# Ultimate Cloudflare Auto-Installer & Manager (Termux Edition)
# Version: 4.4 "Pages Integration"
# Description: A fully automated, intelligent, and robust script for installing
#              a complete Debian environment and deploying Cloudflare services.
# Changelog (4.4):
#   - ADDED FEATURE: Fully automated "Create New Pages Project" function.
#   - FINAL FIXES: Retains the flawless input and automatic login from v4.3.
#=================================================================================

# Exit immediately if a command exits with a non-zero status.
set -e

# --- ANSI Color Codes ---
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Helper Functions ---
print_header() {
    echo -e "${CYAN}=====================================================================${NC}"
    echo -e "${YELLOW}$1${NC}"
    echo -e "${CYAN}=====================================================================${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_error() {
    echo -e "${RED}❌ ERROR: $1. Aborting script.${NC}"
    exit 1
}

# --- Main Logic ---

# 1. Prepare Termux Environment
print_header "Step 1: Preparing Termux Environment"
DEBIAN_FRONTEND=noninteractive pkg update -y || print_error "Failed to update pkg"
DEBIAN_FRONTEND=noninteractive pkg upgrade -y -o Dpkg::Options::="--force-confnew" || print_error "Failed to upgrade pkg"
pkg install proot-distro -y || print_error "Failed to install proot-distro"
print_success "Termux setup complete."

# 2. Install Debian
if ! proot-distro list | grep -q "debian"; then
    print_header "Step 2: Installing Debian with proot-distro"
    echo "This may take several minutes..."
    proot-distro install debian || print_error "Failed to install Debian"
    print_success "Debian installed successfully."
fi

# 3. Setup Debian Environment (NodeJS, Wrangler, etc.)
print_header "Step 3: Setting up Debian Environment"
echo "This involves installing NodeJS, npm, and wrangler..."

proot-distro login debian -- bash -c "
    set -e
    export DEBIAN_FRONTEND=noninteractive
    
    echo -e '${YELLOW}... Updating apt package lists ...${NC}'
    apt update -y
    
    echo -e '${YELLOW}... Upgrading packages ...${NC}'
    apt upgrade -y -o Dpkg::Options::=\"--force-confnew\"
    
    echo -e '${YELLOW}... Installing core dependencies (curl, jq, gnupg, grep) ...${NC}'
    apt install -y curl jq gnupg grep
    
    echo -e '${YELLOW}... Installing modern NodeJS (LTS) ...${NC}'
    curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
    apt-get install -y nodejs
    
    echo -e '${YELLOW}... Installing wrangler globally ...${NC}'
    npm install -g wrangler

" || print_error "Failed to set up Debian environment."

print_success "Debian environment is fully configured."

# 4. Create the Advanced Management Script inside Debian
print_header "Step 4: Creating Advanced Cloudflare Manager"

# Use a quoted heredoc to pass the script content without expansion.
proot-distro login debian -- bash -c "cat > /root/cf_manager.sh" << 'EOF_MANAGER_SCRIPT'
#!/bin/bash
#=================================================================================
# Advanced Cloudflare Management Script
# Version 2.4 "Pages Integration" (Generated by Ultimate Installer)
#=================================================================================

# --- ANSI Color Codes ---
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# --- Helper Functions ---
print_menu_header() {
    echo -e "\n${CYAN}--- Cloudflare Management Menu (v2.4) ---${NC}"
}

# KEY FIX: Forces the 'read' command to listen directly to the keyboard.
press_enter_to_continue() {
    echo -e "\n${YELLOW}Press [Enter] to return to the menu...${NC}"
    read -r < /dev/tty
}

# --- Cloudflare Functions ---

function login_to_cloudflare() {
    local whoami_output
    whoami_output=$(wrangler whoami 2>&1)

    if echo "$whoami_output" | grep -q "You are not authenticated"; then
        echo -e "${YELLOW}Authentication token is invalid or missing. Starting new login automatically...${NC}"
        echo -e "A login link will appear. Open it in your browser and click '${GREEN}Allow${NC}'."
        if ! wrangler login; then
            echo -e "${RED}Login failed. Please try again.${NC}"
            exit 1
        fi
        echo -e "${GREEN}Authentication successful!${NC}"
        wrangler whoami
    else
        echo -e "${GREEN}You are currently logged into Cloudflare as:${NC}"
        echo "$whoami_output"
        echo -e "${YELLOW}Do you want to log in with a different account? (y/n)${NC}"
        read -r re_login < /dev/tty
        if [[ "$re_login" == "y" ]]; then
            echo -e "${YELLOW}Starting new login...${NC}"
            wrangler login
            echo -e "${GREEN}Authentication successful!${NC}"
            wrangler whoami
        fi
    fi
}

function create_vless_worker() {
    set -e
    echo -e "${CYAN}--- Create a New VLESS Worker ---${NC}"
    echo "Enter a name for your new worker (e.g., my-vless-proxy):"
    read -r WORKER_NAME < /dev/tty
    if [ -z "$WORKER_NAME" ]; then echo -e "${RED}Name cannot be empty.${NC}"; return; fi

    echo -e "${YELLOW}Creating project directory: ${GREEN}$WORKER_NAME${NC}...${NC}"
    mkdir -p "$WORKER_NAME" && cd "$WORKER_NAME"

    echo -e "${YELLOW}Generating wrangler.toml...${NC}"
    cat << EOF > wrangler.toml
name = "$WORKER_NAME"
main = "index.js"
compatibility_date = "$(date +%Y-%m-%d)"
EOF

    echo -e "${YELLOW}Injecting the VLESS worker script...${NC}"
    cat << 'EOT' > index.js
// --- START OF VLESS WORKER SCRIPT ---
// This script acts as a powerful reverse proxy.
export default {
    async fetch(request, env) {
        const url = new URL(request.url);
        // Ensure you change the upstream host in the prompt below
        if (url.pathname.startsWith('/')) {
            url.hostname = 'YOUR_UPSTREAM_HOST';
            url.protocol = 'https';
            let new_request = new Request(url, request);
            return fetch(new_request);
        }
        return new Response('Not found', { status: 404 });
    }
};
// --- END OF VLESS WORKER SCRIPT ---
EOT
    
    echo -e "${YELLOW}Please enter your desired upstream host (e.g., example.com):${NC}"
    read -r UPSTREAM_HOST < /dev/tty
    if [ -z "$UPSTREAM_HOST" ]; then echo -e "${RED}Upstream host cannot be empty.${NC}"; cd ..; return; fi
    # Use sed to replace the placeholder in the JS file
    sed -i "s/YOUR_UPSTREAM_HOST/$UPSTREAM_HOST/g" index.js
    
    echo -e "${CYAN}--- Deploying Worker ${GREEN}$WORKER_NAME${NC} ---${NC}"
    wrangler deploy
    
    echo -e "${GREEN}✅ Worker '$WORKER_NAME' deployed successfully!${NC}"
    cd ..
    set +e
}

# --- NEW FUNCTION FOR PAGES ---
function create_pages_project() {
    set -e
    echo -e "${CYAN}--- Create a New Cloudflare Pages Project ---${NC}"
    
    echo "Enter a name for your Pages project:"
    read -r PAGES_PROJECT_NAME < /dev/tty
    if [ -z "$PAGES_PROJECT_NAME" ]; then echo -e "${RED}Project name cannot be empty.${NC}"; return; fi
    
    echo "Enter the path to your static files directory (e.g., /sdcard/my-site):"
    read -r PAGES_DIR < /dev/tty
    
    # Check if directory exists
    if [ ! -d "$PAGES_DIR" ]; then
        echo -e "${RED}Directory '$PAGES_DIR' not found.${NC}"
        echo -e "${YELLOW}Would you like to create a sample directory ($PAGES_PROJECT_NAME) with an index.html file? (y/n)${NC}"
        read -r create_sample_dir < /dev/tty
        if [ "$create_sample_dir" == "y" ]; then
            PAGES_DIR="$PAGES_PROJECT_NAME"
            mkdir -p "$PAGES_DIR"
            echo "<h1>Hello from Cloudflare Pages! Project: $PAGES_PROJECT_NAME</h1>" > "$PAGES_DIR/index.html"
            echo -e "${GREEN}Sample directory created: $PAGES_DIR${NC}"
        else
            echo "Operation cancelled."
            return
        fi
    fi
    
    echo -e "${YELLOW}Deploying directory ${GREEN}$PAGES_DIR${NC} to project ${GREEN}$PAGES_PROJECT_NAME${NC}...${NC}"
    # Use --yes to prevent interactive prompts and --commit-dirty to allow deployment from a non-git directory
    wrangler pages deploy "$PAGES_DIR" --project-name "$PAGES_PROJECT_NAME" --commit-dirty=true --yes
    
    echo -e "${GREEN}✅ Pages project '$PAGES_PROJECT_NAME' deployed successfully!${NC}"
    set +e
}

function delete_worker() {
    echo -e "${CYAN}--- Delete a Cloudflare Worker ---${NC}"
    wrangler worker list
    echo -e "${YELLOW}Enter the exact name of the worker to delete:${NC}"
    read -r WORKER_TO_DELETE < /dev/tty
    if [ -z "$WORKER_TO_DELETE" ]; then echo -e "${RED}Name cannot be empty.${NC}"; return; fi
    
    echo -e "${RED}WARNING: Are you sure you want to delete '$WORKER_TO_DELETE'? (y/n)${NC}"
    read -r confirm < /dev/tty
    if [[ "$confirm" == "y" ]]; then
        wrangler delete "$WORKER_TO_DELETE"
        echo -e "${GREEN}✅ Worker '$WORKER_TO_DELETE' has been deleted.${NC}"
    else
        echo "Deletion cancelled."
    fi
}

function delete_pages_project() {
    echo -e "${CYAN}--- Delete a Cloudflare Pages Project ---${NC}"
    wrangler pages project list
    echo -e "${YELLOW}Enter the exact name of the Pages project to delete:${NC}"
    read -r PAGES_TO_DELETE < /dev/tty
    if [ -z "$PAGES_TO_DELETE" ]; then echo -e "${RED}Name cannot be empty.${NC}"; return; fi
    
    echo -e "${RED}WARNING: Are you sure you want to delete '$PAGES_TO_DELETE'? (y/n)${NC}"
    read -r confirm < /dev/tty
    if [[ "$confirm" == "y" ]]; then
        wrangler pages project delete "$PAGES_TO_DELETE" --yes
        echo -e "${GREEN}✅ Pages project '$PAGES_TO_DELETE' has been deleted.${NC}"
    else
        echo "Deletion cancelled."
    fi
}

function view_worker_logs() {
    echo -e "${CYAN}--- View Live Worker Logs ---${NC}"
    wrangler worker list
    echo -e "${YELLOW}Enter the name of the worker to view its logs:${NC}"
    read -r WORKER_TO_LOG < /dev/tty
    if [ -z "$WORKER_TO_LOG" ]; then echo -e "${RED}Name cannot be empty.${NC}"; return; fi
    echo -e "${CYAN}Streaming logs for '$WORKER_TO_LOG'. Press Ctrl+C to stop.${NC}"
    wrangler tail "$WORKER_TO_LOG"
}

# --- Main Menu Loop ---
login_to_cloudflare

while true; do
    print_menu_header
    echo "1) Create New VLESS Worker"
    echo "2) Create New Pages Project (NEW)"
    echo "3) Delete an existing Worker"
    echo "4) Delete an existing Pages Project"
    echo "5) View Live Logs for a Worker"
    echo "6) List all Workers and Pages"
    echo "7) Check Login Status (whoami)"
    echo -e "${RED}q) Exit${NC}"
    echo "Select an option:"
    # FINAL FIX: Ensures menu input is always read directly from the terminal
    read -r choice < /dev/tty

    case $choice in
        1) create_vless_worker ;;
        2) create_pages_project ;;
        3) delete_worker ;;
        4) delete_pages_project ;;
        5) view_worker_logs ;;
        6) echo -e "${CYAN}--- Workers ---${NC}"; wrangler worker list; echo -e "\n${CYAN}--- Pages ---${NC}"; wrangler pages project list ;;
        7) wrangler whoami ;;
        q|Q) echo "Exiting."; exit 0 ;;
        *) echo -e "${RED}گزینه نامعتبر است. لطفاً دوباره امتحان کنید. (Invalid option)${NC}" ;;
    esac
    press_enter_to_continue
done
EOF_MANAGER_SCRIPT

# 5. Make the Manager Script Executable
print_header "Step 5: Finalizing Installation"
proot-distro login debian -- chmod +x /root/cf_manager.sh || print_error "Failed to make manager script executable"
print_success "Manager script is ready."

# 6. Execute the Manager Script
print_header "Installation Complete! Launching Cloudflare Manager..."
sleep 1
proot-distro login debian -- /root/cf_manager.sh
